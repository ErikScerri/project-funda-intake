# Funda Test Assignment

## Introduction
The assignment was implemented in a simple [Blazor](https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor) web application, which is a web component framework that is bundled in with ASP.NET Core. 

When the application is run, it should open a console window and a browser window. The former displays logging data to track the progress of the data polling. The latter provides a user interface where the recovered and processed data is displayed as the requested tables. Examples are provided below.

> An example console while tasks are running and data is being fetched from the server.
<img width="2560" height="1410" alt="image" src="https://github.com/user-attachments/assets/b1bc2082-209d-43ac-842c-92e939c50dbe" title="An example console while tasks are running and data is being fetched from the server."/>

> An example of the web application when only one of the two separate tasks has completed while the other is still ongoing.
<img width="2560" height="1410" alt="image" src="https://github.com/user-attachments/assets/3b6d6515-73cb-4276-99d3-ebc631f8c065" />

> An example of the web application when all tasks are completed and all data is displayed.
<img width="2560" height="1410" alt="image" src="https://github.com/user-attachments/assets/3e855781-b91e-4d8c-872f-4235bb65257e" />

## Setup

### Packages Used

* Newtonsoft.Json v13.0.4

## Scripts
### Program.cs
The starting script defines and builds the web application, defines services for dependency injection, and maps Razor components. For the simple purposes of this assignment, this script is largely unchanged from the default `Program` script that is generated by VisualStudio when creating a Blazor app from template. Some redundant steps of the app building were removed for simplicity. 

### FundaPollingService.cs
The calls to the API and the processing of response data is done through the `FundaPollingService`, which implements `PollMakelaars` from the `IFundaPollingService` interface. This asynchronous task recieves a feed type (e.g. `"koop"`), a list of query strings (e.g. `["amsterdam", "tuin"]`), and a page size value (which defaults to 25). These parameters generate a URL string to the partner API, with the provided authorisation key, and begin iterating through the pages of the given call. The first call made retrieves pagination data from the JSON object and automatically extends the loop so that all pages are retrieved. Each separate call returns a JSON, which is deserialised and processed into a `Dictionary` of makelaar IDs to makelaar data, where makelaar data has the name of the makelaar and the total tally of listings from the current feed poll. Once all pages have been fetched and processed, the task returns the full list of recovered makelaar data for callers to use as needed. 

Important to note is that the polling task makes use of a `FixedWindowRateLimiter`. This is an inbuilt .NET `RateLimiter` implementation that refreshes allowed permits in a window periodically. In this case, the assignment specified that not more than 100 calls can be made per 1 minute, and so the rate limiter options look as follows:

```csharp
FixedWindowRateLimiterOptions options = new()
{
    PermitLimit = 100,
    Window = TimeSpan.FromMinutes(1),
    QueueLimit = int.MaxValue,
    QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
};
````

Each iteration that fetches a page first waits for the limiter to tell it if it is ok to proceed within the fixed rate (`await limiter.AcquireAsync(1)`). Calls are queued up, so that once the 100 calls limit is reached, subsequent calls simply wait for the window to re-open and then proceed. Since the page size of 25 is quite small in relation to the several thousand objects that need to be recovered, the polling can take several minutes to complete. In a real scenario, a larger page size (or a lack of pagination entirely) would obviously be used to make this query faster, but for the purposes of this assignment it was better to show the rate limiter in action to show how call limit errors can be mitigated. 

In terms of errors, if a request is not succesful or the returned data cannot be deserialised correctly, the polling task will catch the error and display an error log to the console, exiting gracefully. Once again, in a real scenario, it would likely be desirable to retry the call a number of times, or perhaps continue with incomplete data, but since these details were not specified as requirements in the assignment it was preferrable to simply catch and log the errors and neatly close the task as failed.

### Home.razor
The data tables for the assignment are displayed by an [ASP.NET Core Razor component](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-10.0), which injects an implementation of `IFundaPollingService`, calls `PollMakelaars`, and uses the returned list of makelaar data to sort by listing count and generate a top 10 array, which is then displayed into a table by the component framework. This script is very simple, and passes on the implementation of data fetching to the service so as to separate concerns. 

To note, the assignment requires two separate queries to be made and the data from each displayed as a table. Since these two queries are independent of each other, but take very different times to complete, instead of waiting for one to finish and then running the other, they are run in parallel and the component updates accordingly to display data when either task finishes. Inside `OnInitializedAsync`, which is the script that is executed when the component is initialised, both tasks are set off together, and the component is re-rendered when either one finishes. Since both tasks call the same singleton service, which has its own rate limiter instance, they will both respect the same rate limits and queue messages together. This is scalable to any number of parallel tasks.

